// 这里是之前的想法, 后面突然开窍，主要的想法就是，通过在heap中记录一个已经花费的时间，
// 然后, 每次弹出一个后，都更新时间，但是Fix用法不对
type task struct {
	index int
	cost  []int
}
type taskHeap struct {
	costTime int
	tasks    []task
}

func (t *taskHeap) Len() int {
	return len(t.tasks)
}

func (t *taskHeap) Less(i, j int) bool {
	if t.costTime == 0 {
		if t.tasks[i].cost[0] == t.tasks[j].cost[0] {
			return t.tasks[i].cost[1] < t.tasks[j].cost[1]
		}
		return t.tasks[i].cost[0] < t.tasks[j].cost[0]
	}
	iLess := t.tasks[i].cost[0] <= t.costTime
	jLess := t.tasks[j].cost[0] <= t.costTime
	if iLess && jLess {
		processTimeEqual := t.tasks[i].cost[1] == t.tasks[j].cost[1]
		if processTimeEqual {
			return t.tasks[i].index < t.tasks[j].index
		}
		return t.tasks[i].cost[1] < t.tasks[j].cost[1]
	}

	if iLess {
		return true
	}
	if jLess {
		return false
	}
	return true
}

func(t *taskHeap) Swap(i, j int) {
	t.tasks[i], t.tasks[j] = t.tasks[j], t.tasks[i]
}

func (t *taskHeap) Push(x interface{}) {
	t.tasks = append(t.tasks, x.(task))
}

func (t *taskHeap) Pop() interface{} {
	old := t.tasks
	l := len(old)
	x := old[l-1]
	t.tasks = t.tasks[:l-1]
	if t.costTime < x.cost[0] {
		t.costTime = x.cost[0]
	}
	t.costTime += x.cost[1]
	return x
}

func getOrder(tasks [][]int) []int {
	ans := make([]int, len(tasks))
	h := taskHeap{costTime: 0, tasks: make([]task, 0)}
	for i := 0; i < len(tasks); i++ {
		h.tasks = append(h.tasks, task{index: i, cost: tasks[i]})
	}
	heap.Init(&h)

	i := 0
	for h.Len() > 0 {
		x := heap.Pop(&h).(task)
		heap.Fix(&h, 0)
		ans[i] = x.index
		i++
	}

	return ans
}




type task struct {
	index int
	cost  []int
}
type taskHeap struct {
	costTime int
	tasks    []task
}

func (t *taskHeap) Len() int {
	return len(t.tasks)
}

func (t *taskHeap) Less(i, j int) bool {
	iLess := t.tasks[i].cost[0] <= t.costTime
	jLess := t.tasks[j].cost[0] <= t.costTime
	if iLess && jLess {
		if t.tasks[i].cost[1] == t.tasks[j].cost[1] {
			return t.tasks[i].index < t.tasks[j].index
		}
		return t.tasks[i].cost[1] < t.tasks[j].cost[1]
	}

	if !iLess && !jLess {
		waitTimeEqual := t.tasks[i].cost[0] == t.tasks[j].cost[0]
		if waitTimeEqual {
			processTimeEqual := t.tasks[i].cost[1] == t.tasks[j].cost[1]
			if processTimeEqual {
				return t.tasks[i].index < t.tasks[j].index
			}
			return t.tasks[i].cost[1] < t.tasks[j].cost[1]
		}
		return t.tasks[i].cost[0] < t.tasks[j].cost[0]
	}
	return iLess
	/*
		waitTimeEqual := t.tasks[i].cost[0] == t.tasks[j].cost[0]
		if waitTimeEqual {
			processTimeEqual := t.tasks[i].cost[1] == t.tasks[j].cost[1]
			if processTimeEqual {
				return t.tasks[i].index < t.tasks[j].index
			}
			return t.tasks[i].cost[1] < t.tasks[j].cost[1]
		}
		return t.tasks[i].cost[0] < t.tasks[j].cost[0]
	*/

}

func (t *taskHeap) Swap(i, j int) {
	t.tasks[i], t.tasks[j] = t.tasks[j], t.tasks[i]
}

func (t *taskHeap) Push(x interface{}) {
	t.tasks = append(t.tasks, x.(task))
}

func (t *taskHeap) Pop() interface{} {
	old := t.tasks
	l := len(old)
	x := old[l-1]
	t.tasks = t.tasks[:l-1]
	if t.costTime < x.cost[0] {
		t.costTime = x.cost[0]
	}
	t.costTime += x.cost[1]
	return x
}

func getOrder(tasks [][]int) []int {
	ans := make([]int, len(tasks))
	h := taskHeap{costTime: 0, tasks: make([]task, 0)}
	for i := 0; i < len(tasks); i++ {
		h.tasks = append(h.tasks, task{index: i, cost: tasks[i]})
	}
	heap.Init(&h)
	for i := 0; i < len(tasks); i++ {
		heap.Init(&h)
		x := heap.Pop(&h).(task)
		
		ans[i] = x.index
	}

	return ans
}
